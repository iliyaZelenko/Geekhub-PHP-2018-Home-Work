Позволяет объектам с несовместимыми интерфейсами работать вместе.

Используется когда есть две или больше реализаций (в паттерне такая реализация называется `Adaptee`, да, именно `Adaptee`) 
и нужно сделать чтобы через них можно было работать в едином интерфейсе (в паттерне интерфейс имеет `Target`).

Для каждой из таких реализаций нужно создать `Adapter` у которого есть абстрактный адаптер (`Target`).

Пользователь взаимодействует с единым интерфейсом адаптеров которые в свою очередь вызывают свою реализацию (`Adaptee`).

Таким образом `Client` обращается к интерфейсу `Target`, реализованному классом `Adapter`, который перенаправляет обращение к `Adaptee`.

![](https://goo.gl/YLv7gi)

Типичным примером использования шаблона Адаптер можно назвать создание классов, приводящих к единому интерфейсу функции языка PHP обеспечивающие доступ к различным СУБД.

Вариант решения данной проблемы с использованием шаблона Адаптер показан на рисунке.

![](https://upload.wikimedia.org/wikipedia/ru/0/0f/Php_db_adapter.PNG)

Также он делится на три типа:

- [Object adapter pattern](https://en.wikipedia.org/wiki/Adapter_pattern#Object_adapter_pattern).
Это когда Adapter содержит объект клсса который он обертывает и делает вызовы к этому объекту. 
Я так понял тут используется агрегирование в виде композиции (не агрегации), каждый объект адаптер привязан к
своему объекту `Adaptee`. 

На первом рисунке почему-то не видно интерфейс `Target`:
![](https://goo.gl/PTjbqq)
![](https://goo.gl/6bF4xi)

- [Class adapter pattern](https://en.wikipedia.org/wiki/Adapter_pattern#Class_adapter_pattern)

Использует множество полиморфных интерфейсов ([Subtype полиморфизм](https://goo.gl/qOT8w)).
Простыми словами: когда может быть класс `Adapter`, которых обычно несколько, по крайнер мере планируется так, 
(у него обычно интерфейс `Target`, на некоторых диграмах просто не видно),
этот класс привязан к другому классу (`Adaptee`), возможно будет правильно сказать: 
этот класс адаптера проксирует вызовы своих методов в вызовы методов `Adaptee` или другими словами: каждый `Adapter` пытается 
привести свою реализацию (`Adaptee`) в единый интерфейс (`Target`)

На первом рисунке не очень понятно смысл того что от `Adaptor` (тоже странно почему не `Adapter`) показано что от одного 
`Adapter` идет много `Addaptee`, я бы в этом видел смысл если бы было много `Adapter` и у каждого свой `Adaptee`, 
возможно это и подразумевалось, странная диаграмма.

![](https://goo.gl/QTwUsp)
![](https://goo.gl/zTt2iN)

- [Runtime adapter pattern](https://en.wikipedia.org/wiki/Adapter_pattern#A_further_form_of_runtime_adapter_pattern)

Не углублялся, но похоже что на этапе рантайма по какому-то алгоритму создается объект `Adapter` 
и ему через агрегирование передается объект `Adaptee`, к которому потом можно делать вызовы.

Возможно он сильно похож на Object adapter pattern.
